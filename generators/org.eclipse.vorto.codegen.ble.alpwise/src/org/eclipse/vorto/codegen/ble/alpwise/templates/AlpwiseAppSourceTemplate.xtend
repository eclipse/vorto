/*******************************************************************************
 *  Copyright (c) 2017 Oliver Meili
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Eclipse Distribution License v1.0 which accompany this distribution.
 *   
 *  The Eclipse Public License is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *  The Eclipse Distribution License is available at
 *  http://www.eclipse.org/org/documents/edl-v10.php.
 *   
 *  Contributors:
 *  Oliver Meili <omi@ieee.org>
 *******************************************************************************/
package org.eclipse.vorto.codegen.ble.alpwise.templates

import org.eclipse.vorto.core.api.model.informationmodel.InformationModel
import org.eclipse.vorto.codegen.api.InvocationContext

class AlpwiseAppSourceTemplate extends AlpwiseTemplate<InformationModel> {
	
	override getFileName(InformationModel model) {
		return "BleApp.c";
	}
	
	override getPath(InformationModel model) {
		return rootPath
	}
	
	override getContent(InformationModel model, InvocationContext context) {
'''
/* Template generated by Vorto */

/* system header files */
#include <stdio.h>
#include <BCDS_Basics.h>
#include <math.h>

/* additional interface header files */
#include "PTD_portDriver_ph.h"
#include "PTD_portDriver_ih.h"
#include "FreeRTOS.h"
#include "timers.h"
#include "BLE_stateHandler_ih.h"
#include "BLE_serialDriver_ih.h"
#include "attserver.h"
#include "BleGap.h"
#include "BleTypes.h"
#include "BCDS_Magnetometer.h"
#include "BCDS_Environmental.h"
#include "BCDS_Assert.h"

«FOR fb : model.properties»
	«IF context.getMappedElement(fb.type, "Service").hasAttribute("uuid")»
		#include "«fb.type.name»/«fb.type.name».h"
	«ENDIF»
«ENDFOR»

/* public type and macro definitions */
/**< Set BLE Device name */
#define BLEAPP_DEVICE_NAME             "«model.name.toUpperCase»"

/** By running uxTaskGetStackHighWaterMark () freeRTOS API, we found that the maximum stack used by this task is 1040 bytes.
 *  we are adding 10% more as buffer, hence assigning  (configMINIMAL_STACK_SIZE + 32) = 1152 bytes */

#define BLEAPP_STACK_SIZE_FOR_TASK    (configMINIMAL_STACK_SIZE + UINT8_C(32))

/**< TASK Priority value for BLE */
#define BLEAPP_TASK_PRIORITY          UINT8_C(1)

#define BLEAPP_ENABLE_NOTIFICATION    0

static xTaskHandle BleApp_TaskHandle;

«FOR fb : model.properties»
	«FOR status : fb.type.functionblock.status.properties»
		«IF context.getMappedElement(status, "source").hasAttribute("uuid")»
			void «fb.type.name»_Cbk_«status.name.toFirstUpper»(«fb.type.name»_t *«fb.type.name.toLowerCase»)
			{
				«context.getMappedElement(status, "source").getAttributeValue("datatype", "uint16")»_t value;
				
				/* ENTER YOUR CODE TO READ SENSOR DATA HERE */
				value = 0;
				
				«fb.type.name»_Set«status.name.toFirstUpper»Value(«fb.type.name.toLowerCase», value);
			}
			
		«ENDIF»
	«ENDFOR»
«ENDFOR»

void BleApp_ServicesInit(void)
{
	«FOR fb : model.properties»
		«IF context.getMappedElement(fb.type, "Service").hasAttribute("uuid")»
			«fb.type.name»_Init();
		«ENDIF»
	«ENDFOR»
}

static void BleApp_Handler(void *pParameters) {
	(void) pParameters; /* to quiet warnings */

	/* return variable for stack receive status from base band */
	BLE_return_t bleTrsprtRetVal;

	/* return variable for BLE state handler */
	uint8_t bleStateHandleRetVal;

	for (;;) {
		/* Notify the BLE Stack that some data have been received from the Base band(Chip) or Host */
		bleTrsprtRetVal = BLE_hciReceiveData();

		/* This function is used to run the BLE stack and register a BLE device with the specified role */
		bleStateHandleRetVal = BLE_coreStateMachine();

		/* future use */
		UNUSED_PARAMETER(bleTrsprtRetVal);
		UNUSED_PARAMETER(bleStateHandleRetVal);
	}
}

static void BleApp_Cbk_ConnectedNotification(BLE_connectionDetails_t connectionDetails)
{		
	switch (connectionDetails.connectionStatus) {
	case BLE_CONNECTED_TO_DEVICE:
		printf("Device connected  : \r\n");
		/** TODO: Use LED driver instead! */
		PTD_pinOutSet((GPIO_Port_TypeDef) PTD_PORT_LED_ORANGE,
				PTD_PIN_LED_ORANGE);
		break;
	case BLE_DISCONNECTED_FROM_DEVICE:
		printf("Device Disconnected   : \r\n");
		/** TODO: Use LED driver instead! */
		PTD_pinOutClear((GPIO_Port_TypeDef) PTD_PORT_LED_ORANGE,
				PTD_PIN_LED_ORANGE);
		break;
	default:
		assert(0);
		break;
	}
}

void BleApp_Init(void)
{
	BLE_notification_t configParams;

	/* return value for BLE task create */
	BleStatus bleInitReturn;
	int8_t bleTaskInitReturn;

	BLE_returnStatus_t _returnValue = BLE_setDeviceName(
			(uint8_t *) BLEAPP_DEVICE_NAME, strlen(BLEAPP_DEVICE_NAME));
	assert(_returnValue == BLE_SUCCESS);

	/* enable and register notification callback for bluetooth device connect and disconnect*/
	configParams.callback = BleApp_Cbk_ConnectedNotification;
	configParams.enableNotification = BLEAPP_ENABLE_NOTIFICATION;

	BLE_enablenotificationForConnect(configParams);

	/* Registering the BLE Services  */
	BleApp_ServicesInit();

	/* Initialize the whole BLE stack */
	bleInitReturn = BLE_coreStackInit();

	if (BLESTATUS_FAILED == bleInitReturn) {
		assert(0);
		printf("BLE Boot up process Failed,.! \n");
	} else {
		/* Task creating for BTLE stateHandler to establish the connection */
		bleTaskInitReturn = xTaskCreate((xTaskHandle) BleApp_Handler,
				(const char * const ) "BLE", BLEAPP_STACK_SIZE_FOR_TASK, NULL,
				BLEAPP_TASK_PRIORITY, &BleApp_TaskHandle);

		/* BLE task creatioon fail case */
		if (pdPASS != bleTaskInitReturn) {
			printf("BLE Task was not created, Due to Insufficient heap memory");
			assert(0);
		} else {
			printf("BLE Task created and stack initialized \n");
		}
	}	
}

void BleApp_Deinit(void) {
	/*Suspend the BLE task*/
	vTaskSuspend((xTaskHandle) &BleApp_TaskHandle);
}
'''
	}		
}